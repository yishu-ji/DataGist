<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive DWT Plot</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script>
        console.log("Numeric.js loaded:", typeof numeric !== "undefined");
    </script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #chart-container { width: 90%; height: 500px; margin: auto; }
        #slider-container { width: 600px; margin: 20px auto; }
        #slider-DWT-1 { width: 100%; }
    </style>
</head>
<body>

    <h3>Interactive Approximated Plot - Discrete Wavelet Transform (DWT)</h3>

    <div id="slider-container">
        <input type="range" id="slider-DWT-1" min="0.05" max="1" step="0.05" value="0.05">
        <span id="alpha-value">Parameter: 0.2</span>
    </div>

    <div id="chart-container">
        <div id="chart"></div>
    </div>

    <script>
        let data = []; // Global variable to store data

        d3.json("https://yishu-ji.github.io/DataGist/data.json").then(function(loadedData) {
            console.log("Data loaded successfully:", loadedData);
            
            data = loadedData; // Store data globally
            data.forEach(d => d.date = new Date(d.date));

            if (!data || data.length === 0) {
                console.error("Data failed to load or is empty.");
                return;
            }

            updateChart(0.5); // Initial plot
        }).catch(function(error) {
            console.error("Error loading data.json:", error);
        });

        function denoiseSignalDWT(values, threshold) {
    let coeffs = numeric.clone(values); // Simulating wavelet decomposition
    
    // Simulate multi-level decomposition (5 levels)
    let levels = 5;
    let waveletCoeffs = [];
    for (let i = 0; i < levels; i++) {
        let step = Math.pow(2, i);
        let subband = values.filter((_, index) => index % step === 0); // Approximate decomposition
        waveletCoeffs.push(subband);
    }

    // Apply thresholding to all levels except the first (approximate coefficients)
    for (let i = 1; i < waveletCoeffs.length; i++) {
        let maxVal = Math.max(...waveletCoeffs[i].map(Math.abs));
        waveletCoeffs[i] = waveletCoeffs[i].map(v => Math.abs(v) > threshold * maxVal ? v : 0);
    }

    // Reconstruct signal (simulating inverse DWT)
    let reconstructed = new Array(values.length).fill(0);
    for (let i = 0; i < waveletCoeffs.length; i++) {
        let step = Math.pow(2, i);
        for (let j = 0; j < waveletCoeffs[i].length; j++) {
            reconstructed[j * step] += waveletCoeffs[i][j];
        }
    }
    return reconstructed;
}



        function updateChart(alpha) {
            if (!data.length) {
                console.error("Data is not available yet.");
                return;
            }
            
            let smoothedData = denoiseSignalDWT(data.map(d => d.value), alpha);

            // Remove first and last 200 data points
            let trimmedData = data.slice(200, data.length - 200);
            let trimmedSmoothedValues = smoothedData.slice(200, smoothedData.length - 200);
            // let trimmedSmoothedData = smoothedData.slice(200, smoothedData.length - 200);
            let trimmedDates = data.slice(200, data.length - 200);

            let traceOriginal = {
                x: trimmedDates.map(d => d.date),
                y: trimmedDates.map(d => d.value),
                mode: "lines",
                name: "Original Data",
                line: { color: "lightgray" }
            };

            let traceDWT = {
                x: trimmedData.map(d => d.date),
                y: trimmedSmoothedValues,
                mode: "lines",
                name: `Approximated Data (Threshold: ${alpha})`,
                line: { color: "blue" }
            };

            Plotly.newPlot("chart", [traceOriginal, traceDWT], {
                title: " ",
                xaxis: { title: "Date", tickformat: "%Y-%m" },
                yaxis: { title: "Value" },
                width: 900,  // Custom width
                height: 500, // Custom height
                responsive: true  // Enable auto-resizing
            });
        }

        function sendSliderValueToQualtrics(fieldName, alpha) {
            console.log(`Sending to Qualtrics: ${fieldName} = ${alpha.toFixed(2)}`);
            window.parent.postMessage({ fieldName: fieldName, value: alpha.toFixed(2) }, "*");
        }

        function initializeSlider(sliderId, fieldName) {
            d3.select(`#${sliderId}`).on("input", function() {
                let alpha = +this.value;
                d3.select(`#alpha-value`).text(`Parameter: ${alpha.toFixed(2)}`);
                updateChart(alpha);
                clearTimeout(window[sliderId + "_timeout"]);
                window[sliderId + "_timeout"] = setTimeout(() => {
                    sendSliderValueToQualtrics(fieldName, alpha);
                }, 1000);
            });

            window.addEventListener("beforeunload", function() {
                let finalAlpha = +d3.select(`#${sliderId}`).property("value");
                sendSliderValueToQualtrics(fieldName, finalAlpha);
            });
        }

        initializeSlider("slider-DWT-1", "parameter-DWT-1");
    </script>
</body>
</html>
