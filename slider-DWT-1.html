<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive DWT Plot</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script>
        console.log("Numeric.js loaded:", typeof numeric !== "undefined");
    </script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<!--     <script src="https://symmetronic.github.io/discrete-wavelets/build/discrete-wavelets.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/discrete-wavelets@5/dist/discrete-wavelets.umd.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        #chart-container { width: 90%; height: 500px; margin: auto; }
        #slider-container { width: 600px; margin: 20px auto; }
        #slider-DWT-1 { width: 100%; }
    </style>
</head>
<body>

    <h3>Interactive Approximated Plot - Discrete Wavelet Transform (DWT)</h3>

    <div id="slider-container">
        <input type="range" id="slider-DWT-1" min="0.05" max="1" step="0.05" value="0.05">
        <span id="alpha-value">Parameter: 0.2</span>
    </div>

    <div id="chart-container">
        <div id="chart"></div>
    </div>

    <script>
        
        let data = []; // Global variable to store data

        d3.json("https://yishu-ji.github.io/DataGist/data.json").then(function(loadedData) {
            console.log("Data loaded successfully:", loadedData);
            
            data = loadedData; // Store data globally
            data.forEach(d => d.date = new Date(d.date));

            if (!data || data.length === 0) {
                console.error("Data failed to load or is empty.");
                return;
            }

            updateChart(0.5); // Initial plot
        }).catch(function(error) {
            console.error("Error loading data.json:", error);
        });

        // function denoiseSignalDWT(values, waveletName = 'db6', level = 5, thresholdPercent = 0.2) {
        //   // 1. Multi-level DWT in one step
        //   let {approx, details} = wavelet.mdwt(values, waveletName, level);

        //   // 2. Threshold detail coefficients
        //       details.forEach((detailLevel, idx) => {
        //         let maxVal = Math.max(...detailLevel.map(Math.abs));
        //         let thresh = thresholdPercent * maxVal;
        //         // Zero out small detail coefficients
        //         details[idx] = detailLevel.map(val => (Math.abs(val) > thresh ? val : 0));
        //       });

        //   // 3. Reconstruct the signal
        //   let reconstructed = wavelet.midwt(approx, details, waveletName, level);
        //   return reconstructed;
        //     }

    // waveletName = 'db6', level = 5, threshold = alpha (0 <= alpha <= ?)
function denoiseSignalDWT(values, waveletName, level, threshold) {
  // 1. Create wavelet transform instance
  // DiscreteWavelets is exposed by the UMD build: 
  // <script src="https://cdn.jsdelivr.net/npm/discrete-wavelets@5/dist/discrete-wavelets.umd.min.js"></script>
  const wt = new DiscreteWavelets.WT(waveletName);

  // 2. Decompose the signal into approximation & detail coefficients
  // 'level' controls how many times decomposition is applied
  // e.g., level = 5
  const { approx, details } = wt.dwt(values, level);

  // 3. Threshold the detail coefficients
  // We do a "hard" threshold: zero out small values
  details.forEach((detailArr) => {
    const maxVal = Math.max(...detailArr.map(Math.abs));
    const t = threshold * maxVal; // threshold scaled by max coefficient
    for (let i = 0; i < detailArr.length; i++) {
      if (Math.abs(detailArr[i]) < t) {
        detailArr[i] = 0;
      }
    }
  });

  // 4. Reconstruct the signal
  const reconstructed = wt.idwt(approx, details);
  return reconstructed; // returns an array of numeric values
}

        function updateChart(alpha) {
  if (!data.length) {
    console.error("Data is not available yet.");
    return;
  }

  // 1. Perform wavelet-based denoising
  // e.g., waveletName = 'db6' and level = 5
  const waveletName = "db6";
  const level = 5;
  const smoothedData = denoiseSignalDWT(
    data.map(d => d.value),
    waveletName,
    level,
    alpha
  );

  // 2. Trim edges (like in Python)
  const trimmedDates = data.slice(200, data.length - 200);
  const trimmedValues = smoothedData.slice(200, smoothedData.length - 200);

  // 3. Build Plotly traces
  const traceOriginal = {
    x: trimmedDates.map(d => d.date),
    y: trimmedDates.map(d => d.value),
    mode: "lines",
    name: "Original Data",
    line: { color: "lightgray" }
  };

  const traceDWT = {
    x: trimmedDates.map(d => d.date),
    y: trimmedValues,
    mode: "lines",
    name: `DWT (Threshold: ${alpha})`,
    line: { color: "blue" }
  };

  // 4. Plot with Plotly
  Plotly.newPlot("chart", [traceOriginal, traceDWT], {
    title: "Discrete Wavelet Transform Denoising",
    xaxis: { title: "Date", tickformat: "%Y-%m" },
    yaxis: { title: "Value" },
    width: 900,
    height: 500,
    responsive: true
  });
}



        
        // function updateChart(alpha) {
        //   // Perform wavelet-based denoising
        //   let smoothedData = denoiseSignalDWT(data.map(d => d.value), 'db6', 5, alpha);

        //   // Then remove edge points, etc.
        //     let trimmedData = data.slice(200, data.length - 200);
        //     let trimmedSmoothedValues = smoothedData.slice(200, smoothedData.length - 200);
        //     // let trimmedSmoothedData = smoothedData.slice(200, smoothedData.length - 200);
        //     let trimmedDates = data.slice(200, data.length - 200);

  
        //     let traceOriginal = {
        //         x: trimmedDates.map(d => d.date),
        //         y: trimmedDates.map(d => d.value),
        //         mode: "lines",
        //         name: "Original Data",
        //         line: { color: "lightgray" }
        //     };

        //     let traceDWT = {
        //         x: trimmedData.map(d => d.date),
        //         y: trimmedSmoothedValues,
        //         mode: "lines",
        //         name: `Approximated Data (Threshold: ${alpha})`,
        //         line: { color: "blue" }
        //     };

        //     Plotly.newPlot("chart", [traceOriginal, traceDWT], {
        //         title: " ",
        //         xaxis: { title: "Date", tickformat: "%Y-%m" },
        //         yaxis: { title: "Value" },
        //         width: 900,  // Custom width
        //         height: 500, // Custom height
        //         responsive: true  // Enable auto-resizing
        //     });
        // }

function updateChart(alpha) {
  // 1. Ensure data is loaded
  if (!data.length) {
    console.error("Data is not available yet.");
    return;
  }
  
  // 2. Perform DWT-based denoising
  let waveletName = "db6";
  let level = 5;
  let smoothedData = denoiseSignalDWT(data.map(d => d.value), waveletName, level, alpha);

  // 3. Slice off edges (like Python)
  let trimmedDates = data.slice(200, data.length - 200);
  let trimmedValues = smoothedData.slice(200, smoothedData.length - 200);

  // 4. Build traces
  let traceOriginal = {
    x: trimmedDates.map(d => d.date),
    y: trimmedDates.map(d => d.value),
    mode: "lines",
    name: "Original Data",
    line: { color: "lightgray" }
  };

  let traceDWT = {
    x: trimmedDates.map(d => d.date),
    y: trimmedValues,
    mode: "lines",
    name: `Approximated Data (Threshold: ${alpha})`,
    line: { color: "blue" }
  };

  // 5. Plot
  Plotly.newPlot("chart", [traceOriginal, traceDWT], {
    title: "Discrete Wavelet Transform Denoising",
    xaxis: { title: "Date", tickformat: "%Y-%m" },
    yaxis: { title: "Value" },
    width: 900,
    height: 500,
    responsive: true
  });
}


        function sendSliderValueToQualtrics(fieldName, alpha) {
            console.log(`Sending to Qualtrics: ${fieldName} = ${alpha.toFixed(2)}`);
            window.parent.postMessage({ fieldName: fieldName, value: alpha.toFixed(2) }, "*");
        }

        function initializeSlider(sliderId, fieldName) {
            d3.select(`#${sliderId}`).on("input", function() {
                let alpha = +this.value;
                d3.select(`#alpha-value`).text(`Parameter: ${alpha.toFixed(2)}`);
                updateChart(alpha);
                clearTimeout(window[sliderId + "_timeout"]);
                window[sliderId + "_timeout"] = setTimeout(() => {
                    sendSliderValueToQualtrics(fieldName, alpha);
                }, 1000);
            });

            window.addEventListener("beforeunload", function() {
                let finalAlpha = +d3.select(`#${sliderId}`).property("value");
                sendSliderValueToQualtrics(fieldName, finalAlpha);
            });
        }

        initializeSlider("slider-DWT-1", "parameter-DWT-1");
    </script>
</body>
</html>
